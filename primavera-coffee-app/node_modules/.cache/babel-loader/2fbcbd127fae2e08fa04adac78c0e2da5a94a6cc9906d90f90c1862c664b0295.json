{"ast":null,"code":"import { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nclass BaseAnimation {\n  constructor({\n    autoplay = true,\n    delay = 0,\n    type = \"keyframes\",\n    repeat = 0,\n    repeatDelay = 0,\n    repeatType = \"loop\",\n    ...options\n  }) {\n    // Track whether the animation has been stopped. Stopped animations won't restart.\n    this.isStopped = false;\n    this.options = {\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      ...options\n    };\n    this.updateFinishedPromise();\n  }\n  /**\n   * A getter for resolved data. If keyframes are not yet resolved, accessing\n   * this.resolved will synchronously flush all pending keyframe resolvers.\n   * This is a deoptimisation, but at its worst still batches read/writes.\n   */\n  get resolved() {\n    if (!this._resolved) flushKeyframeResolvers();\n    return this._resolved;\n  }\n  /**\n   * A method to be called when the keyframes resolver completes. This method\n   * will check if its possible to run the animation and, if not, skip it.\n   * Otherwise, it will call initPlayback on the implementing class.\n   */\n  onKeyframesResolved(keyframes, finalKeyframe) {\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      onComplete,\n      onUpdate\n    } = this.options;\n    /**\n     * If we can't animate this value with the resolved keyframes\n     * then we should complete it immediately.\n     */\n    if (!canAnimate(keyframes, name, type, velocity)) {\n      // Finish immediately\n      if (instantAnimationState.current || !delay) {\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        return;\n      }\n      // Finish after a delay\n      else {\n        this.options.duration = 0;\n      }\n    }\n    this._resolved = {\n      keyframes,\n      finalKeyframe,\n      ...this.initPlayback(keyframes, finalKeyframe)\n    };\n    this.onPostResolved();\n  }\n  onPostResolved() {}\n  /**\n   * Allows the returned animation to be awaited or promise-chained. Currently\n   * resolves when the animation finishes at all but in a future update could/should\n   * reject if its cancels.\n   */\n  then(resolve, reject) {\n    return this.currentFinishedPromise.then(resolve, reject);\n  }\n  updateFinishedPromise() {\n    this.currentFinishedPromise = new Promise(resolve => {\n      this.resolveFinishedPromise = () => {\n        resolve();\n        this.updateFinishedPromise();\n      };\n    });\n  }\n}\nexport { BaseAnimation };","map":{"version":3,"names":["flushKeyframeResolvers","instantAnimationState","canAnimate","getFinalKeyframe","BaseAnimation","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","options","isStopped","updateFinishedPromise","resolved","_resolved","onKeyframesResolved","keyframes","finalKeyframe","name","velocity","onComplete","onUpdate","current","resolveFinishedPromise","duration","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","Promise"],"sources":["/Users/nick/primavera-coffee/primavera-coffee-app/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"],"sourcesContent":["import { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved)\n            flushKeyframeResolvers();\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        const { name, type, velocity, delay, onComplete, onUpdate } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n                this.resolveFinishedPromise();\n                this.updateFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...this.initPlayback(keyframes, finalKeyframe),\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = () => {\n                resolve();\n                this.updateFinishedPromise();\n            };\n        });\n    }\n}\n\nexport { BaseAnimation };\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,0CAA0C;AACjF,SAASC,qBAAqB,QAAQ,8CAA8C;AACpF,SAASC,UAAU,QAAQ,yBAAyB;AACpD,SAASC,gBAAgB,QAAQ,sCAAsC;AAEvE,MAAMC,aAAa,CAAC;EAChBC,WAAWA,CAAC;IAAEC,QAAQ,GAAG,IAAI;IAAEC,KAAK,GAAG,CAAC;IAAEC,IAAI,GAAG,WAAW;IAAEC,MAAM,GAAG,CAAC;IAAEC,WAAW,GAAG,CAAC;IAAEC,UAAU,GAAG,MAAM;IAAE,GAAGC;EAAQ,CAAC,EAAE;IAC1H;IACA,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACD,OAAO,GAAG;MACXN,QAAQ;MACRC,KAAK;MACLC,IAAI;MACJC,MAAM;MACNC,WAAW;MACXC,UAAU;MACV,GAAGC;IACP,CAAC;IACD,IAAI,CAACE,qBAAqB,CAAC,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIC,QAAQA,CAAA,EAAG;IACX,IAAI,CAAC,IAAI,CAACC,SAAS,EACfhB,sBAAsB,CAAC,CAAC;IAC5B,OAAO,IAAI,CAACgB,SAAS;EACzB;EACA;AACJ;AACA;AACA;AACA;EACIC,mBAAmBA,CAACC,SAAS,EAAEC,aAAa,EAAE;IAC1C,MAAM;MAAEC,IAAI;MAAEZ,IAAI;MAAEa,QAAQ;MAAEd,KAAK;MAAEe,UAAU;MAAEC;IAAS,CAAC,GAAG,IAAI,CAACX,OAAO;IAC1E;AACR;AACA;AACA;IACQ,IAAI,CAACV,UAAU,CAACgB,SAAS,EAAEE,IAAI,EAAEZ,IAAI,EAAEa,QAAQ,CAAC,EAAE;MAC9C;MACA,IAAIpB,qBAAqB,CAACuB,OAAO,IAAI,CAACjB,KAAK,EAAE;QACzCgB,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACpB,gBAAgB,CAACe,SAAS,EAAE,IAAI,CAACN,OAAO,EAAEO,aAAa,CAAC,CAAC;QACtHG,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAAC,CAAC;QACpE,IAAI,CAACG,sBAAsB,CAAC,CAAC;QAC7B,IAAI,CAACX,qBAAqB,CAAC,CAAC;QAC5B;MACJ;MACA;MAAA,KACK;QACD,IAAI,CAACF,OAAO,CAACc,QAAQ,GAAG,CAAC;MAC7B;IACJ;IACA,IAAI,CAACV,SAAS,GAAG;MACbE,SAAS;MACTC,aAAa;MACb,GAAG,IAAI,CAACQ,YAAY,CAACT,SAAS,EAAEC,aAAa;IACjD,CAAC;IACD,IAAI,CAACS,cAAc,CAAC,CAAC;EACzB;EACAA,cAAcA,CAAA,EAAG,CAAE;EACnB;AACJ;AACA;AACA;AACA;EACIC,IAAIA,CAACC,OAAO,EAAEC,MAAM,EAAE;IAClB,OAAO,IAAI,CAACC,sBAAsB,CAACH,IAAI,CAACC,OAAO,EAAEC,MAAM,CAAC;EAC5D;EACAjB,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACkB,sBAAsB,GAAG,IAAIC,OAAO,CAAEH,OAAO,IAAK;MACnD,IAAI,CAACL,sBAAsB,GAAG,MAAM;QAChCK,OAAO,CAAC,CAAC;QACT,IAAI,CAAChB,qBAAqB,CAAC,CAAC;MAChC,CAAC;IACL,CAAC,CAAC;EACN;AACJ;AAEA,SAASV,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}